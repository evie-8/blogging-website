"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length, i, keys;\n    if (a && b && typeof a == \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\nfunction useFloating(_temp) {\n    let { middleware, placement = \"bottom\", strategy = \"absolute\", whileElementsMounted } = _temp === void 0 ? {} : _temp;\n    const reference = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const floating = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const cleanupRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        // Setting these to `null` will allow the consumer to determine if\n        // `computePosition()` has run yet\n        x: null,\n        y: null,\n        strategy,\n        placement,\n        middlewareData: {}\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_1__.useState(middleware);\n    if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref)=>{\n        let { options } = _ref;\n        return options;\n    }), middleware == null ? void 0 : middleware.map((_ref2)=>{\n        let { options } = _ref2;\n        return options;\n    }))) {\n        setLatestMiddleware(middleware);\n    }\n    const update = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        if (!reference.current || !floating.current) {\n            return;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference.current, floating.current, {\n            middleware: latestMiddleware,\n            placement,\n            strategy\n        }).then((data)=>{\n            if (isMountedRef.current) {\n                react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(()=>{\n                    setData(data);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy\n    ]);\n    index(()=>{\n        // Skip first update\n        if (isMountedRef.current) {\n            update();\n        }\n    }, [\n        update\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    const runElementMountCallback = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        if (typeof cleanupRef.current === \"function\") {\n            cleanupRef.current();\n            cleanupRef.current = null;\n        }\n        if (reference.current && floating.current) {\n            if (whileElementsMountedRef.current) {\n                const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);\n                cleanupRef.current = cleanupFn;\n            } else {\n                update();\n            }\n        }\n    }, [\n        update,\n        whileElementsMountedRef\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((node)=>{\n        reference.current = node;\n        runElementMountCallback();\n    }, [\n        runElementMountCallback\n    ]);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((node)=>{\n        floating.current = node;\n        runElementMountCallback();\n    }, [\n        runElementMountCallback\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            reference,\n            floating\n        }), []);\n    return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            reference: setReference,\n            floating: setFloating\n        }), [\n        data,\n        update,\n        refs,\n        setReference,\n        setFloating\n    ]);\n}\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>{\n    const { element, padding } = options;\n    function isRef(value) {\n        return Object.prototype.hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (args) {\n            if (isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(args);\n                }\n                return {};\n            } else if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.arrow)({\n                    element,\n                    padding\n                }).fn(args);\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUU7QUFDcEM7QUFDRjtBQUNvQjtBQUNiO0FBRXRDLElBQUlPLFFBQVEsT0FBT0MsYUFBYSxjQUFjSixrREFBZUEsR0FBR0MsNENBQVNBO0FBRXpFLGdGQUFnRjtBQUNoRixZQUFZO0FBQ1osU0FBU0ksVUFBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JCLElBQUlELE1BQU1DLEdBQUc7UUFDWCxPQUFPO0lBQ1Q7SUFFQSxJQUFJLE9BQU9ELE1BQU0sT0FBT0MsR0FBRztRQUN6QixPQUFPO0lBQ1Q7SUFFQSxJQUFJLE9BQU9ELE1BQU0sY0FBY0EsRUFBRUUsUUFBUSxPQUFPRCxFQUFFQyxRQUFRLElBQUk7UUFDNUQsT0FBTztJQUNUO0lBRUEsSUFBSUMsUUFBUUMsR0FBR0M7SUFFZixJQUFJTCxLQUFLQyxLQUFLLE9BQU9ELEtBQUssVUFBVTtRQUNsQyxJQUFJTSxNQUFNQyxPQUFPLENBQUNQLElBQUk7WUFDcEJHLFNBQVNILEVBQUVHLE1BQU07WUFDakIsSUFBSUEsVUFBVUYsRUFBRUUsTUFBTSxFQUFFLE9BQU87WUFFL0IsSUFBS0MsSUFBSUQsUUFBUUMsUUFBUSxHQUFJO2dCQUMzQixJQUFJLENBQUNMLFVBQVVDLENBQUMsQ0FBQ0ksRUFBRSxFQUFFSCxDQUFDLENBQUNHLEVBQUUsR0FBRztvQkFDMUIsT0FBTztnQkFDVDtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUFDLE9BQU9HLE9BQU9ILElBQUksQ0FBQ0w7UUFDbkJHLFNBQVNFLEtBQUtGLE1BQU07UUFFcEIsSUFBSUEsV0FBV0ssT0FBT0gsSUFBSSxDQUFDSixHQUFHRSxNQUFNLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBRUEsSUFBS0MsSUFBSUQsUUFBUUMsUUFBUSxHQUFJO1lBQzNCLElBQUksQ0FB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QSxDQUFDO3dCQUNiNkQsU0FBU0EsUUFBUW5DLE9BQU87d0JBQ3hCb0M7b0JBQ0YsR0FBR0csRUFBRSxDQUFDQztnQkFDUjtnQkFFQSxPQUFPLENBQUM7WUFDVixPQUFPLElBQUlMLFNBQVM7Z0JBQ2xCLE9BQU83RCx1REFBT0EsQ0FBQztvQkFDYjZEO29CQUNBQztnQkFDRixHQUFHRyxFQUFFLENBQUNDO1lBQ1I7WUFFQSxPQUFPLENBQUM7UUFDVjtJQUVGO0FBQ0Y7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5lc20uanM/NmYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24sIGFycm93IGFzIGFycm93JDEgfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCAqIGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyBGb3JrIG9mIGBmYXN0LWRlZXAtZXF1YWxgIHRoYXQgb25seSBkb2VzIHRoZSBjb21wYXJpc29ucyB3ZSBuZWVkIGFuZCBjb21wYXJlc1xuLy8gZnVuY3Rpb25zXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbGV0IGxlbmd0aCwgaSwga2V5cztcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuZnVuY3Rpb24gdXNlRmxvYXRpbmcoX3RlbXApIHtcbiAgbGV0IHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHdoaWxlRWxlbWVudHNNb3VudGVkUmVmID0gdXNlTGF0ZXN0UmVmKHdoaWxlRWxlbWVudHNNb3VudGVkKTtcbiAgY29uc3QgY2xlYW51cFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIC8vIFNldHRpbmcgdGhlc2UgdG8gYG51bGxgIHdpbGwgYWxsb3cgdGhlIGNvbnN1bWVyIHRvIGRldGVybWluZSBpZlxuICAgIC8vIGBjb21wdXRlUG9zaXRpb24oKWAgaGFzIHJ1biB5ZXRcbiAgICB4OiBudWxsLFxuICAgIHk6IG51bGwsXG4gICAgc3RyYXRlZ3ksXG4gICAgcGxhY2VtZW50LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fVxuICB9KTtcbiAgY29uc3QgW2xhdGVzdE1pZGRsZXdhcmUsIHNldExhdGVzdE1pZGRsZXdhcmVdID0gUmVhY3QudXNlU3RhdGUobWlkZGxld2FyZSk7XG5cbiAgaWYgKCFkZWVwRXF1YWwobGF0ZXN0TWlkZGxld2FyZSA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0TWlkZGxld2FyZS5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSksIG1pZGRsZXdhcmUgPT0gbnVsbCA/IHZvaWQgMCA6IG1pZGRsZXdhcmUubWFwKF9yZWYyID0+IHtcbiAgICBsZXQge1xuICAgICAgb3B0aW9uc1xuICAgIH0gPSBfcmVmMjtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSkpKSB7XG4gICAgc2V0TGF0ZXN0TWlkZGxld2FyZShtaWRkbGV3YXJlKTtcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZS5jdXJyZW50IHx8ICFmbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29tcHV0ZVBvc2l0aW9uKHJlZmVyZW5jZS5jdXJyZW50LCBmbG9hdGluZy5jdXJyZW50LCB7XG4gICAgICBtaWRkbGV3YXJlOiBsYXRlc3RNaWRkbGV3YXJlLFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3lcbiAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgc2V0RGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsYXRlc3RNaWRkbGV3YXJlLCBwbGFjZW1lbnQsIHN0cmF0ZWd5XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICAvLyBTa2lwIGZpcnN0IHVwZGF0ZVxuICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9LCBbdXBkYXRlXSk7XG4gIGNvbnN0IGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBydW5FbGVtZW50TW91bnRDYWxsYmFjayA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGNsZWFudXBSZWYuY3VycmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2xlYW51cFJlZi5jdXJyZW50KCk7XG4gICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2UuY3VycmVudCAmJiBmbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KHJlZmVyZW5jZS5jdXJyZW50LCBmbG9hdGluZy5jdXJyZW50LCB1cGRhdGUpO1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSBjbGVhbnVwRm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFt1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHJlZmVyZW5jZS5jdXJyZW50ID0gbm9kZTtcbiAgICBydW5FbGVtZW50TW91bnRDYWxsYmFjaygpO1xuICB9LCBbcnVuRWxlbWVudE1vdW50Q2FsbGJhY2tdKTtcbiAgY29uc3Qgc2V0RmxvYXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBmbG9hdGluZy5jdXJyZW50ID0gbm9kZTtcbiAgICBydW5FbGVtZW50TW91bnRDYWxsYmFjaygpO1xuICB9LCBbcnVuRWxlbWVudE1vdW50Q2FsbGJhY2tdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSksIFtdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHsgLi4uZGF0YSxcbiAgICB1cGRhdGUsXG4gICAgcmVmcyxcbiAgICByZWZlcmVuY2U6IHNldFJlZmVyZW5jZSxcbiAgICBmbG9hdGluZzogc2V0RmxvYXRpbmdcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIHNldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbn1cblxuLyoqXG4gKiBQb3NpdGlvbnMgYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzdWNoIHRoYXQgaXQgaXMgY2VudGVyZWRcbiAqIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuXG5jb25zdCBhcnJvdyA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCB7XG4gICAgZWxlbWVudCxcbiAgICBwYWRkaW5nXG4gIH0gPSBvcHRpb25zO1xuXG4gIGZ1bmN0aW9uIGlzUmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuXG4gICAgZm4oYXJncykge1xuICAgICAgaWYgKGlzUmVmKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcnJvdyQxKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICB9KS5mbihhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYXJyb3ckMSh7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBwYWRkaW5nXG4gICAgICAgIH0pLmZuKGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgdXNlRmxvYXRpbmcgfTtcbiJdLCJuYW1lcyI6WyJjb21wdXRlUG9zaXRpb24iLCJhcnJvdyIsImFycm93JDEiLCJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsIlJlYWN0RE9NIiwiaW5kZXgiLCJkb2N1bWVudCIsImRlZXBFcXVhbCIsImEiLCJiIiwidG9TdHJpbmciLCJsZW5ndGgiLCJpIiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImtleSIsIiQkdHlwZW9mIiwidXNlTGF0ZXN0UmVmIiwidmFsdWUiLCJyZWYiLCJ1c2VSZWYiLCJjdXJyZW50IiwidXNlRmxvYXRpbmciLCJfdGVtcCIsIm1pZGRsZXdhcmUiLCJwbGFjZW1lbnQiLCJzdHJhdGVneSIsIndoaWxlRWxlbWVudHNNb3VudGVkIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJ3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiIsImNsZWFudXBSZWYiLCJkYXRhIiwic2V0RGF0YSIsInVzZVN0YXRlIiwieCIsInkiLCJtaWRkbGV3YXJlRGF0YSIsImxhdGVzdE1pZGRsZXdhcmUiLCJzZXRMYXRlc3RNaWRkbGV3YXJlIiwibWFwIiwiX3JlZiIsIm9wdGlvbnMiLCJfcmVmMiIsInVwZGF0ZSIsInVzZUNhbGxiYWNrIiwidGhlbiIsImlzTW91bnRlZFJlZiIsImZsdXNoU3luYyIsInJ1bkVsZW1lbnRNb3VudENhbGxiYWNrIiwiY2xlYW51cEZuIiwic2V0UmVmZXJlbmNlIiwibm9kZSIsInNldEZsb2F0aW5nIiwicmVmcyIsInVzZU1lbW8iLCJlbGVtZW50IiwicGFkZGluZyIsImlzUmVmIiwibmFtZSIsImZuIiwiYXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getMainAxisFromPlacement(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"x\" : \"y\";\n}\nfunction getLengthFromAxis(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const mainAxis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(mainAxis);\n    const commonAlign = reference[length] / 2 - floating[length] / 2;\n    const side = getSide(placement);\n    const isVertical = mainAxis === \"x\";\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch(getAlignment(placement)){\n        case \"start\":\n            coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    if (true) {\n        if (platform == null) {\n            console.error([\n                \"Floating UI: `platform` property was not passed to config. If you\",\n                \"want to use Floating UI on the web, install @floating-ui/dom\",\n                \"instead of the /core package. Otherwise, you can create your own\",\n                \"`platform`: https://floating-ui.com/docs/platform\"\n            ].join(\" \"));\n        }\n        if (middleware.filter((_ref)=>{\n            let { name } = _ref;\n            return name === \"autoPlacement\" || name === \"flip\";\n        }).length > 1) {\n            throw new Error([\n                \"Floating UI: duplicate `flip` and/or `autoPlacement`\",\n                \"middleware detected. This will lead to an infinite loop. Ensure only\",\n                \"one of either has been passed to the `middleware` array.\"\n            ].join(\" \"));\n        }\n    }\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < middleware.length; i++){\n        const { name, fn } = middleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (true) {\n            if (resetCount > 50) {\n                console.warn([\n                    \"Floating UI: The middleware lifecycle appears to be running in an\",\n                    \"infinite loop. This is usually caused by a `reset` continually\",\n                    \"being returned without a break condition.\"\n                ].join(\" \"));\n            }\n        }\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n            continue;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getSideObjectFromPadding(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    return {\n        ...rect,\n        top: rect.y,\n        left: rect.x,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(middlewareArguments, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = middlewareArguments;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = options;\n    const paddingObject = getSideObjectFromPadding(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: elementContext === \"floating\" ? {\n            ...rects.floating,\n            x,\n            y\n        } : rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n    }) : rects[elementContext]);\n    return {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n}\nconst min = Math.min;\nconst max = Math.max;\nfunction within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n}\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (middlewareArguments) {\n            // Since `element` is required, we don't Partial<> the type\n            const { element, padding = 0 } = options != null ? options : {};\n            const { x, y, placement, rects, platform } = middlewareArguments;\n            if (element == null) {\n                if (true) {\n                    console.warn(\"Floating UI: No `element` was passed to the `arrow` middleware.\");\n                }\n                return {};\n            }\n            const paddingObject = getSideObjectFromPadding(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = getMainAxisFromPlacement(placement);\n            const alignment = getAlignment(placement);\n            const length = getLengthFromAxis(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const minProp = axis === \"y\" ? \"top\" : \"left\";\n            const maxProp = axis === \"y\" ? \"bottom\" : \"right\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n            if (clientSize === 0) {\n                clientSize = rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds\n            const min = paddingObject[minProp];\n            const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = within(min, center, max); // Make sure that arrow points at the reference\n            const alignmentPadding = alignment === \"start\" ? paddingObject[minProp] : paddingObject[maxProp];\n            const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n            const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n            return {\n                [axis]: coords[axis] - alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset\n                }\n            };\n        }\n    });\nconst hash$1 = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (matched)=>hash$1[matched]);\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const mainAxis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(mainAxis);\n    let mainAlignmentSide = mainAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return {\n        main: mainAlignmentSide,\n        cross: getOppositePlacement(mainAlignmentSide)\n    };\n}\nconst hash = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (matched)=>hash[matched]);\n}\nconst sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst allPlacements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-start\", side + \"-end\"), []);\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>getAlignment(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>getAlignment(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>getSide(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (middlewareArguments) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n            const { x, y, rects, middlewareData, placement, platform, elements } = middlewareArguments;\n            const { alignment = null, allowedPlacements = allPlacements, autoAlignment = true, ...detectOverflowOptions } = options;\n            const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n            const currentPlacement = placements[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const { main, cross } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n            if (placement !== currentPlacement) {\n                return {\n                    x,\n                    y,\n                    reset: {\n                        placement: placements[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[getSide(currentPlacement)],\n                overflow[main],\n                overflow[cross]\n            ];\n            const allOverflows = [\n                ...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b)=>a.overflows[0] - b.overflows[0]);\n            const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref)=>{\n                let { overflows } = _ref;\n                return overflows.every((overflow)=>overflow <= 0);\n            })) == null ? void 0 : _placementsSortedByLe.placement;\n            const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (middlewareArguments) {\n            var _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = middlewareArguments;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", flipAlignment = true, ...detectOverflowOptions } = options;\n            const side = getSide(placement);\n            const isBasePlacement = side === initialPlacement;\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                getOppositePlacement(initialPlacement)\n            ] : getExpandedPlacements(initialPlacement));\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const { main, cross } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n                overflows.push(overflow[main], overflow[cross]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ]; // One or more sides is overflowing\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip$, _middlewareData$flip2;\n                const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                let resetPlacement = \"bottom\";\n                switch(fallbackStrategy){\n                    case \"bestFit\":\n                        {\n                            var _overflowsData$map$so;\n                            const placement = (_overflowsData$map$so = overflowsData.map((d)=>[\n                                    d,\n                                    d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n                            if (placement) {\n                                resetPlacement = placement;\n                            }\n                            break;\n                        }\n                    case \"initialPlacement\":\n                        resetPlacement = initialPlacement;\n                        break;\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(_temp) {\n    let { strategy = \"referenceHidden\", ...detectOverflowOptions } = _temp === void 0 ? {} : _temp;\n    return {\n        name: \"hide\",\n        async fn (middlewareArguments) {\n            const { rects } = middlewareArguments;\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(middlewareArguments, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(middlewareArguments, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nasync function convertValueToCoords(middlewareArguments, value) {\n    const { placement, platform, elements } = middlewareArguments;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = getSide(placement);\n    const alignment = getAlignment(placement);\n    const isVertical = getMainAxisFromPlacement(placement) === \"x\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = typeof value === \"function\" ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        alignmentAxis: null,\n        ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(value) {\n    if (value === void 0) {\n        value = 0;\n    }\n    return {\n        name: \"offset\",\n        options: value,\n        async fn (middlewareArguments) {\n            const { x, y } = middlewareArguments;\n            const diffCoords = await convertValueToCoords(middlewareArguments, value);\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: diffCoords\n            };\n        }\n    };\n};\nfunction getCrossAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (middlewareArguments) {\n            const { x, y, placement } = middlewareArguments;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = options;\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const mainAxis = getMainAxisFromPlacement(getSide(placement));\n            const crossAxis = getCrossAxis(mainAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = within(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = within(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...middlewareArguments,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (middlewareArguments) {\n            const { x, y, placement, rects, middlewareData } = middlewareArguments;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = options;\n            const coords = {\n                x,\n                y\n            };\n            const mainAxis = getMainAxisFromPlacement(placement);\n            const crossAxis = getCrossAxis(mainAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = typeof offset === \"function\" ? offset({\n                ...rects,\n                placement\n            }) : offset;\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes(getSide(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (middlewareArguments) {\n            const { placement, rects, platform, elements } = middlewareArguments;\n            const { apply, ...detectOverflowOptions } = options;\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const side = getSide(placement);\n            const alignment = getAlignment(placement);\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const xMin = max(overflow.left, 0);\n            const xMax = max(overflow.right, 0);\n            const yMin = max(overflow.top, 0);\n            const yMax = max(overflow.bottom, 0);\n            const dimensions = {\n                availableHeight: rects.floating.height - ([\n                    \"left\",\n                    \"right\"\n                ].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n                availableWidth: rects.floating.width - ([\n                    \"top\",\n                    \"bottom\"\n                ].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n            };\n            const prevDimensions = await platform.getDimensions(elements.floating);\n            apply == null ? void 0 : apply({\n                ...middlewareArguments,\n                ...dimensions\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (middlewareArguments) {\n            var _await$platform$getCl;\n            const { placement, elements, rects, platform, strategy } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = options;\n            const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n                rect: rects.reference,\n                offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n                strategy\n            }) : rects.reference);\n            const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n            const paddingObject = getSideObjectFromPadding(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    var _clientRects$find;\n                    // Find the first rect in which the point is fully inside\n                    return (_clientRects$find = clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n                } // There are 2 or more connected rects\n                if (clientRects.length >= 2) {\n                    if (getMainAxisFromPlacement(placement) === \"x\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = getSide(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = getSide(placement) === \"left\";\n                    const maxRight = max(...clientRects.map((rect)=>rect.right));\n                    const minLeft = min(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxRQUFRQyxTQUFTO0lBQ3hCLE9BQU9BLFVBQVVDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNoQztBQUVBLFNBQVNDLGFBQWFGLFNBQVM7SUFDN0IsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDO0FBRUEsU0FBU0UseUJBQXlCSCxTQUFTO0lBQ3pDLE9BQU87UUFBQztRQUFPO0tBQVMsQ0FBQ0ksUUFBUSxDQUFDTCxRQUFRQyxjQUFjLE1BQU07QUFDaEU7QUFFQSxTQUFTSyxrQkFBa0JDLElBQUk7SUFDN0IsT0FBT0EsU0FBUyxNQUFNLFdBQVc7QUFDbkM7QUFFQSxTQUFTQywyQkFBMkJDLElBQUksRUFBRVIsU0FBUyxFQUFFUyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0g7SUFDSixNQUFNSSxVQUFVRixVQUFVRyxDQUFDLEdBQUdILFVBQVVJLEtBQUssR0FBRyxJQUFJSCxTQUFTRyxLQUFLLEdBQUc7SUFDckUsTUFBTUMsVUFBVUwsVUFBVU0sQ0FBQyxHQUFHTixVQUFVTyxNQUFNLEdBQUcsSUFBSU4sU0FBU00sTUFBTSxHQUFHO0lBQ3ZFLE1BQU1DLFdBQVdmLHlCQUF5Qkg7SUFDMUMsTUFBTW1CLFNBQVNkLGtCQUFrQmE7SUFDakMsTUFBTUUsY0FBY1YsU0FBUyxDQUFDUyxPQUFPLEdBQUcsSUFBSVIsUUFBUSxDQUFDUSxPQUFPLEdBQUc7SUFDL0QsTUFBTUUsT0FBT3RCLFFBQVFDO0lBQ3JCLE1BQU1zQixhQUFhSixhQUFhO0lBQ2hDLElBQUlLO0lBRUosT0FBUUY7UUFDTixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BWLEdBQUdEO2dCQUNISSxHQUFHTixVQUFVTSxDQUFDLEdBQUdMLFNBQVNNLE1B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Q0FBQyxLQUFLNk4sV0FBV2hPLFNBQVMsQ0FBQ0csQ0FBQyxJQUFJd0IsTUFBTTNCLFNBQVMsQ0FBQ00sQ0FBQyxLQUFLME4sV0FBV2hPLFNBQVMsQ0FBQ00sQ0FBQyxJQUFJcUIsTUFBTTNCLFNBQVMsQ0FBQ0ksS0FBSyxLQUFLNE4sV0FBV2hPLFNBQVMsQ0FBQ0ksS0FBSyxJQUFJdUIsTUFBTTNCLFNBQVMsQ0FBQ08sTUFBTSxLQUFLeU4sV0FBV2hPLFNBQVMsQ0FBQ08sTUFBTSxFQUFFO2dCQUNsTixPQUFPO29CQUNMOEIsT0FBTzt3QkFDTFYsT0FBT3FNO29CQUNUO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPLENBQUM7UUFDVjtJQUVGO0FBQ0Y7QUFFd0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcz81NmJmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldFNpZGUocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5cbmZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneCcgOiAneSc7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aEZyb21BeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0TGVuZ3RoRnJvbUF4aXMobWFpbkF4aXMpO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVtsZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2xlbmd0aF0gLyAyO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gbWFpbkF4aXMgPT09ICd4JztcbiAgbGV0IGNvb3JkcztcblxuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGZsb2F0aW5nLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBmbG9hdGluZy53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1ttYWluQXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW21haW5BeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIHBvc2l0aW9uaW5nIHN0cmF0ZWd5LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cblxuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gYXN5bmMgKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZykgPT4ge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChwbGF0Zm9ybSA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnRmxvYXRpbmcgVUk6IGBwbGF0Zm9ybWAgcHJvcGVydHkgd2FzIG5vdCBwYXNzZWQgdG8gY29uZmlnLiBJZiB5b3UnLCAnd2FudCB0byB1c2UgRmxvYXRpbmcgVUkgb24gdGhlIHdlYiwgaW5zdGFsbCBAZmxvYXRpbmctdWkvZG9tJywgJ2luc3RlYWQgb2YgdGhlIC9jb3JlIHBhY2thZ2UuIE90aGVyd2lzZSwgeW91IGNhbiBjcmVhdGUgeW91ciBvd24nLCAnYHBsYXRmb3JtYDogaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9wbGF0Zm9ybSddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgaWYgKG1pZGRsZXdhcmUuZmlsdGVyKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gJ2F1dG9QbGFjZW1lbnQnIHx8IG5hbWUgPT09ICdmbGlwJztcbiAgICB9KS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoWydGbG9hdGluZyBVSTogZHVwbGljYXRlIGBmbGlwYCBhbmQvb3IgYGF1dG9QbGFjZW1lbnRgJywgJ21pZGRsZXdhcmUgZGV0ZWN0ZWQuIFRoaXMgd2lsbCBsZWFkIHRvIGFuIGluZmluaXRlIGxvb3AuIEVuc3VyZSBvbmx5JywgJ29uZSBvZiBlaXRoZXIgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSBgbWlkZGxld2FyZWAgYXJyYXkuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9KTtcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCk7XG4gIGxldCBzdGF0ZWZ1bFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgbGV0IG1pZGRsZXdhcmVEYXRhID0ge307XG4gIGxldCByZXNldENvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1pZGRsZXdhcmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gbWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0geyAuLi5taWRkbGV3YXJlRGF0YSxcbiAgICAgIFtuYW1lXTogeyAuLi5taWRkbGV3YXJlRGF0YVtuYW1lXSxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAocmVzZXRDb3VudCA+IDUwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBUaGUgbWlkZGxld2FyZSBsaWZlY3ljbGUgYXBwZWFycyB0byBiZSBydW5uaW5nIGluIGFuJywgJ2luZmluaXRlIGxvb3AuIFRoaXMgaXMgdXN1YWxseSBjYXVzZWQgYnkgYSBgcmVzZXRgIGNvbnRpbnVhbGx5JywgJ2JlaW5nIHJldHVybmVkIHdpdGhvdXQgYSBicmVhayBjb25kaXRpb24uJ10uam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuXG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzZXQucmVjdHMpIHtcbiAgICAgICAgICByZWN0cyA9IHJlc2V0LnJlY3RzID09PSB0cnVlID8gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG5cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG5cbiAgICAgIGkgPSAtMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNpZGVPYmplY3RGcm9tUGFkZGluZyhwYWRkaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIDoge1xuICAgIHRvcDogcGFkZGluZyxcbiAgICByaWdodDogcGFkZGluZyxcbiAgICBib3R0b206IHBhZGRpbmcsXG4gICAgbGVmdDogcGFkZGluZ1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIHsgLi4ucmVjdCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG5cbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFNpZGVPYmplY3RGcm9tUGFkZGluZyhwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICByZWN0OiBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHsgLi4ucmVjdHMuZmxvYXRpbmcsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gOiByZWN0cy5yZWZlcmVuY2UsXG4gICAgb2Zmc2V0UGFyZW50OiBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKSxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3RzW2VsZW1lbnRDb250ZXh0XSk7XG4gIHJldHVybiB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbn1cblxuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcblxuZnVuY3Rpb24gd2l0aGluKG1pbiQxLCB2YWx1ZSwgbWF4JDEpIHtcbiAgcmV0dXJuIG1heChtaW4kMSwgbWluKHZhbHVlLCBtYXgkMSkpO1xufVxuXG4vKipcbiAqIFBvc2l0aW9ucyBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBpdCBpcyBjZW50ZXJlZFxuICogdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuXG4gIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZVxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtXG4gICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmxvYXRpbmcgVUk6IE5vIGBlbGVtZW50YCB3YXMgcGFzc2VkIHRvIHRoZSBgYXJyb3dgIG1pZGRsZXdhcmUuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0TGVuZ3RoRnJvbUF4aXMoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG5cbiAgICBpZiAoY2xpZW50U2l6ZSA9PT0gMCkge1xuICAgICAgY2xpZW50U2l6ZSA9IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kc1xuXG4gICAgY29uc3QgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBNYWtlIHN1cmUgdGhhdCBhcnJvdyBwb2ludHMgYXQgdGhlIHJlZmVyZW5jZVxuXG4gICAgY29uc3QgYWxpZ25tZW50UGFkZGluZyA9IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/IHBhZGRpbmdPYmplY3RbbWluUHJvcF0gOiBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICAgIGNvbnN0IHNob3VsZEFkZE9mZnNldCA9IGFsaWdubWVudFBhZGRpbmcgPiAwICYmIGNlbnRlciAhPT0gb2Zmc2V0ICYmIHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdIDw9IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3QgYWxpZ25tZW50T2Zmc2V0ID0gc2hvdWxkQWRkT2Zmc2V0ID8gY2VudGVyIDwgbWluID8gbWluIC0gY2VudGVyIDogbWF4IC0gY2VudGVyIDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gLSBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldFxuICAgICAgfVxuICAgIH07XG4gIH1cblxufSk7XG5cbmNvbnN0IGhhc2gkMSA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBtYXRjaGVkID0+IGhhc2gkMVttYXRjaGVkXSk7XG59XG5cbmZ1bmN0aW9uIGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCkge1xuICBpZiAocnRsID09PSB2b2lkIDApIHtcbiAgICBydGwgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhtYWluQXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG5cbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYWluOiBtYWluQWxpZ25tZW50U2lkZSxcbiAgICBjcm9zczogZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXG4gIH07XG59XG5cbmNvbnN0IGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIG1hdGNoZWQgPT4gaGFzaFttYXRjaGVkXSk7XG59XG5cbmNvbnN0IHNpZGVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmNvbnN0IGFsbFBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLXN0YXJ0XCIsIHNpZGUgKyBcIi1lbmRcIiksIFtdKTtcblxuZnVuY3Rpb24gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSB7XG4gIGNvbnN0IGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQgPSBhbGlnbm1lbnQgPyBbLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50KSwgLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPT0gYWxpZ25tZW50KV0gOiBhbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldFNpZGUocGxhY2VtZW50KSA9PT0gcGxhY2VtZW50KTtcbiAgcmV0dXJuIGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQuZmlsdGVyKHBsYWNlbWVudCA9PiB7XG4gICAgaWYgKGFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQgfHwgKGF1dG9BbGlnbm1lbnQgPyBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpICE9PSBwbGFjZW1lbnQgOiBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgY2hvb3NlcyB0aGUgYHBsYWNlbWVudGAgd2hpY2ggaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDMsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDQsIF9wbGFjZW1lbnRzU29ydGVkQnlMZTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxpZ25tZW50ID0gbnVsbCxcbiAgICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBhbGxQbGFjZW1lbnRzLFxuICAgICAgICBhdXRvQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKF9taWRkbGV3YXJlRGF0YSRhdXRvUCA9IChfbWlkZGxld2FyZURhdGEkYXV0b1AyID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDIuaW5kZXgpICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkYXV0b1AgOiAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHNbY3VycmVudEluZGV4XTtcblxuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbixcbiAgICAgICAgY3Jvc3NcbiAgICAgIH0gPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTsgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2VcblxuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gY3VycmVudFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1ttYWluXSwgb3ZlcmZsb3dbY3Jvc3NdXTtcbiAgICAgIGNvbnN0IGFsbE92ZXJmbG93cyA9IFsuLi4oKF9taWRkbGV3YXJlRGF0YSRhdXRvUDMgPSAoX21pZGRsZXdhcmVEYXRhJGF1dG9QNCA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1A0Lm92ZXJmbG93cykgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRhdXRvUDMgOiBbXSksIHtcbiAgICAgICAgcGxhY2VtZW50OiBjdXJyZW50UGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3M6IGN1cnJlbnRPdmVyZmxvd3NcbiAgICAgIH1dO1xuICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbY3VycmVudEluZGV4ICsgMV07IC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2tcblxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlMZWFzdE92ZXJmbG93ID0gYWxsT3ZlcmZsb3dzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMF0gLSBiLm92ZXJmbG93c1swXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRUaGF0Rml0c09uQWxsU2lkZXMgPSAoX3BsYWNlbWVudHNTb3J0ZWRCeUxlID0gcGxhY2VtZW50c1NvcnRlZEJ5TGVhc3RPdmVyZmxvdy5maW5kKF9yZWYgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIG92ZXJmbG93c1xuICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIG92ZXJmbG93cy5ldmVyeShvdmVyZmxvdyA9PiBvdmVyZmxvdyA8PSAwKTtcbiAgICAgIH0pKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNTb3J0ZWRCeUxlLnBsYWNlbWVudDtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50VGhhdEZpdHNPbkFsbFNpZGVzICE9IG51bGwgPyBwbGFjZW1lbnRUaGF0Rml0c09uQWxsU2lkZXMgOiBwbGFjZW1lbnRzU29ydGVkQnlMZWFzdE92ZXJmbG93WzBdLnBsYWNlbWVudDtcblxuICAgICAgaWYgKHJlc2V0UGxhY2VtZW50ICE9PSBwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgcGxhY2VtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHRvIG9uZSB0aGF0IHdpbGwgZml0IGlmIHRoZVxuICogaW5pdGlhbGx5IHNwZWNpZmllZCBgcGxhY2VtZW50YCBkb2VzIG5vdC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZmxpcCcsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IHNpZGUgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IFtpbml0aWFsUGxhY2VtZW50LCAuLi5mYWxsYmFja1BsYWNlbWVudHNdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcblxuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1haW4sXG4gICAgICAgICAgY3Jvc3NcbiAgICAgICAgfSA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W21haW5dLCBvdmVyZmxvd1tjcm9zc10pO1xuICAgICAgfVxuXG4gICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3NcbiAgICAgIH1dOyAvLyBPbmUgb3IgbW9yZSBzaWRlcyBpcyBvdmVyZmxvd2luZ1xuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwJCwgX21pZGRsZXdhcmVEYXRhJGZsaXAyO1xuXG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAkID0gKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkZmxpcCQgOiAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG5cbiAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAvLyBUcnkgbmV4dCBwbGFjZW1lbnQgYW5kIHJlLXJ1biB0aGUgbGlmZWN5Y2xlXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9ICdib3R0b20nO1xuXG4gICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgIGNhc2UgJ2Jlc3RGaXQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkbWFwJHNvO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRtYXAkc28gPSBvdmVyZmxvd3NEYXRhLm1hcChkID0+IFtkLCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJG1hcCRzb1swXS5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAoX3RlbXApIHtcbiAgbGV0IHtcbiAgICBzdHJhdGVneSA9ICdyZWZlcmVuY2VIaWRkZW4nLFxuICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0c1xuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG5cbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIHsgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZXNjYXBlZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCB7IC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvQ29vcmRzKG1pZGRsZXdhcmVBcmd1bWVudHMsIHZhbHVlKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHNcbiAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gJ3gnO1xuICBjb25zdCBtYWluQXhpc011bHRpID0gWydsZWZ0JywgJ3RvcCddLmluY2x1ZGVzKHNpZGUpID8gLTEgOiAxO1xuICBjb25zdCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxO1xuICBjb25zdCByYXdWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKG1pZGRsZXdhcmVBcmd1bWVudHMpIDogdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcblxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsLFxuICAgIC4uLnJhd1ZhbHVlXG4gIH07XG5cbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuXG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuLyoqXG4gKiBEaXNwbGFjZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgZnJvbSBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cblxuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgdmFsdWUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zOiB2YWx1ZSxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMobWlkZGxld2FyZUFyZ3VtZW50cywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIGRpZmZDb29yZHMueCxcbiAgICAgICAgeTogeSArIGRpZmZDb29yZHMueSxcbiAgICAgICAgZGF0YTogZGlmZkNvb3Jkc1xuICAgICAgfTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldENyb3NzQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5cbi8qKlxuICogU2hpZnRzIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIGEgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0Q3Jvc3NBeGlzKG1haW5BeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuXG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gbWFpbkF4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBtYWluQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIG1haW5BeGlzQ29vcmQgPSB3aXRoaW4obWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gY3Jvc3NBeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gY3Jvc3NBeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSB3aXRoaW4obWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGltaXRlZENvb3JkcyA9IGxpbWl0ZXIuZm4oeyAuLi5taWRkbGV3YXJlQXJndW1lbnRzLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG5cbiAgICBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0Q3Jvc3NBeGlzKG1haW5BeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgY29uc3QgcmF3T2Zmc2V0ID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldCh7IC4uLnJlY3RzLFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0pIDogb2Zmc2V0O1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG5cbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gLSBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcblxuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMiwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMywgX21pZGRsZXdhcmVEYXRhJG9mZnNlNDtcblxuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBpc09yaWdpblNpZGUgPSBbJ3RvcCcsICdsZWZ0J10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSAhPSBudWxsID8gX21pZGRsZXdhcmVEYXRhJG9mZnNlIDogMCA6IDApICsgKGlzT3JpZ2luU2lkZSA/IDAgOiBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMpO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gMCA6IChfbWlkZGxld2FyZURhdGEkb2Zmc2UzID0gKF9taWRkbGV3YXJlRGF0YSRvZmZzZTQgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2U0W2Nyb3NzQXhpc10pICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkb2Zmc2UzIDogMCkgLSAoaXNPcmlnaW5TaWRlID8gY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzIDogMCk7XG5cbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuIEZvciBpbnN0YW5jZSxcbiAqIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyBpdHMgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlIHdpZHRoIG9mIHRoZVxuICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IG1pZGRsZXdhcmVBcmd1bWVudHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwcGx5LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhtaWRkbGV3YXJlQXJndW1lbnRzLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuXG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IHNpZGU7XG4gICAgICAgIHdpZHRoU2lkZSA9IGFsaWdubWVudCA9PT0gKChhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpID8gJ3N0YXJ0JyA6ICdlbmQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aFNpZGUgPSBzaWRlO1xuICAgICAgICBoZWlnaHRTaWRlID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgIGNvbnN0IHlNaW4gPSBtYXgob3ZlcmZsb3cudG9wLCAwKTtcbiAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgICAgIGF2YWlsYWJsZUhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0IC0gKFsnbGVmdCcsICdyaWdodCddLmluY2x1ZGVzKHBsYWNlbWVudCkgPyAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSkgOiBvdmVyZmxvd1toZWlnaHRTaWRlXSksXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCAtIChbJ3RvcCcsICdib3R0b20nXS5pbmNsdWRlcyhwbGFjZW1lbnQpID8gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpIDogb3ZlcmZsb3dbd2lkdGhTaWRlXSlcbiAgICAgIH07XG4gICAgICBjb25zdCBwcmV2RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgYXBwbHkgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGx5KHsgLi4ubWlkZGxld2FyZUFyZ3VtZW50cyxcbiAgICAgICAgLi4uZGltZW5zaW9uc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuXG4gICAgICBpZiAocHJldkRpbWVuc2lvbnMud2lkdGggIT09IG5leHREaW1lbnNpb25zLndpZHRoIHx8IHByZXZEaW1lbnNpb25zLmhlaWdodCAhPT0gbmV4dERpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRnZXRDbDtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50czsgLy8gQSBNb3VzZUV2ZW50J3MgY2xpZW50e1gsWX0gY29vcmRzIGNhbiBiZSB1cCB0byAyIHBpeGVscyBvZmYgYVxuICAgICAgLy8gQ2xpZW50UmVjdCdzIGJvdW5kcywgZGVzcGl0ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYmVpbmcgdHJpZ2dlcmVkLiBBXG4gICAgICAvLyBwYWRkaW5nIG9mIDIgc2VlbXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuXG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgICAgICByZWN0OiByZWN0cy5yZWZlcmVuY2UsXG4gICAgICAgIG9mZnNldFBhcmVudDogYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnRzLmZsb2F0aW5nKSksXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KSA6IHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IChfYXdhaXQkcGxhdGZvcm0kZ2V0Q2wgPSBhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGdldENsIDogW107XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZFxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbGllbnRSZWN0cyRmaW5kO1xuXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlXG4gICAgICAgICAgcmV0dXJuIChfY2xpZW50UmVjdHMkZmluZCA9IGNsaWVudFJlY3RzLmZpbmQocmVjdCA9PiB4ID4gcmVjdC5sZWZ0IC0gcGFkZGluZ09iamVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCAmJiB5ID4gcmVjdC50b3AgLSBwYWRkaW5nT2JqZWN0LnRvcCAmJiB5IDwgcmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkpICE9IG51bGwgPyBfY2xpZW50UmVjdHMkZmluZCA6IGZhbGxiYWNrO1xuICAgICAgICB9IC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzXG5cblxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkgPT09ICd4Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHJlY3RUb0NsaWVudFJlY3QsIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IiwiaW5jbHVkZXMiLCJnZXRMZW5ndGhGcm9tQXhpcyIsImF4aXMiLCJjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudCIsIl9yZWYiLCJydGwiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsImNvbW1vblgiLCJ4Iiwid2lkdGgiLCJjb21tb25ZIiwieSIsImhlaWdodCIsIm1haW5BeGlzIiwibGVuZ3RoIiwiY29tbW9uQWxpZ24iLCJzaWRlIiwiaXNWZXJ0aWNhbCIsImNvb3JkcyIsImNvbXB1dGVQb3NpdGlvbiIsImNvbmZpZyIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsInBsYXRmb3JtIiwiaXNSVEwiLCJwcm9jZXNzIiwiY29uc29sZSIsImVycm9yIiwiam9pbiIsImZpbHRlciIsIm5hbWUiLCJFcnJvciIsInJlY3RzIiwiZ2V0RWxlbWVudFJlY3RzIiwic3RhdGVmdWxQbGFjZW1lbnQiLCJtaWRkbGV3YXJlRGF0YSIsInJlc2V0Q291bnQiLCJpIiwiZm4iLCJuZXh0WCIsIm5leHRZIiwiZGF0YSIsInJlc2V0IiwiaW5pdGlhbFBsYWNlbWVudCIsImVsZW1lbnRzIiwid2FybiIsImV4cGFuZFBhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nIiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJkZXRlY3RPdmVyZmxvdyIsIm1pZGRsZXdhcmVBcmd1bWVudHMiLCJvcHRpb25zIiwiX2F3YWl0JHBsYXRmb3JtJGlzRWxlIiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q29udGV4dCIsImFsdEJvdW5kYXJ5IiwicGFkZGluZ09iamVjdCIsImFsdENvbnRleHQiLCJlbGVtZW50IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiaXNFbGVtZW50IiwiY29udGV4dEVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJlbGVtZW50Q2xpZW50UmVjdCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0Iiwib2Zmc2V0UGFyZW50IiwiZ2V0T2Zmc2V0UGFyZW50IiwibWluIiwiTWF0aCIsIm1heCIsIndpdGhpbiIsIm1pbiQxIiwidmFsdWUiLCJtYXgkMSIsImFycm93IiwiYWxpZ25tZW50IiwiYXJyb3dEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsIm1pblByb3AiLCJtYXhQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNsaWVudEhlaWdodCIsImNsaWVudFdpZHRoIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJjZW50ZXIiLCJvZmZzZXQiLCJhbGlnbm1lbnRQYWRkaW5nIiwic2hvdWxkQWRkT2Zmc2V0IiwiYWxpZ25tZW50T2Zmc2V0IiwiY2VudGVyT2Zmc2V0IiwiaGFzaCQxIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJyZXBsYWNlIiwibWF0Y2hlZCIsImdldEFsaWdubWVudFNpZGVzIiwibWFpbkFsaWdubWVudFNpZGUiLCJtYWluIiwiY3Jvc3MiLCJoYXNoIiwic3RhcnQiLCJlbmQiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsInNpZGVzIiwiYWxsUGxhY2VtZW50cyIsInJlZHVjZSIsImFjYyIsImNvbmNhdCIsImdldFBsYWNlbWVudExpc3QiLCJhdXRvQWxpZ25tZW50IiwiYWxsb3dlZFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50IiwiYXV0b1BsYWNlbWVudCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUDIiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AzIiwiX21pZGRsZXdhcmVEYXRhJGF1dG9QNCIsIl9wbGFjZW1lbnRzU29ydGVkQnlMZSIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsInBsYWNlbWVudHMiLCJvdmVyZmxvdyIsImN1cnJlbnRJbmRleCIsImluZGV4IiwiY3VycmVudFBsYWNlbWVudCIsImN1cnJlbnRPdmVyZmxvd3MiLCJhbGxPdmVyZmxvd3MiLCJvdmVyZmxvd3MiLCJuZXh0UGxhY2VtZW50IiwicGxhY2VtZW50c1NvcnRlZEJ5TGVhc3RPdmVyZmxvdyIsInNsaWNlIiwic29ydCIsImEiLCJiIiwicGxhY2VtZW50VGhhdEZpdHNPbkFsbFNpZGVzIiwiZmluZCIsImV2ZXJ5IiwicmVzZXRQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImZsaXAiLCJfbWlkZGxld2FyZURhdGEkZmxpcCIsImNoZWNrTWFpbkF4aXMiLCJjcm9zc0F4aXMiLCJjaGVja0Nyb3NzQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmbGlwQWxpZ25tZW50IiwiaXNCYXNlUGxhY2VtZW50Iiwib3ZlcmZsb3dzRGF0YSIsInB1c2giLCJfbWlkZGxld2FyZURhdGEkZmxpcCQiLCJfbWlkZGxld2FyZURhdGEkZmxpcDIiLCJuZXh0SW5kZXgiLCJfb3ZlcmZsb3dzRGF0YSRtYXAkc28iLCJtYXAiLCJkIiwiZ2V0U2lkZU9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwiaGlkZSIsIl90ZW1wIiwib2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbk9mZnNldHMiLCJyZWZlcmVuY2VIaWRkZW4iLCJlc2NhcGVkT2Zmc2V0cyIsImVzY2FwZWQiLCJjb252ZXJ0VmFsdWVUb0Nvb3JkcyIsIm1haW5BeGlzTXVsdGkiLCJjcm9zc0F4aXNNdWx0aSIsInJhd1ZhbHVlIiwiYWxpZ25tZW50QXhpcyIsImRpZmZDb29yZHMiLCJnZXRDcm9zc0F4aXMiLCJzaGlmdCIsImxpbWl0ZXIiLCJtYWluQXhpc0Nvb3JkIiwiY3Jvc3NBeGlzQ29vcmQiLCJtaW5TaWRlIiwibWF4U2lkZSIsImxpbWl0ZWRDb29yZHMiLCJsaW1pdFNoaWZ0IiwicmF3T2Zmc2V0IiwiY29tcHV0ZWRPZmZzZXQiLCJsZW4iLCJsaW1pdE1pbiIsImxpbWl0TWF4IiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlIiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlMiIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZTMiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2U0IiwiaXNPcmlnaW5TaWRlIiwic2l6ZSIsImFwcGx5IiwiaGVpZ2h0U2lkZSIsIndpZHRoU2lkZSIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJkaW1lbnNpb25zIiwiYXZhaWxhYmxlSGVpZ2h0IiwiYXZhaWxhYmxlV2lkdGgiLCJwcmV2RGltZW5zaW9ucyIsIm5leHREaW1lbnNpb25zIiwiaW5saW5lIiwiX2F3YWl0JHBsYXRmb3JtJGdldENsIiwiZmFsbGJhY2siLCJjbGllbnRSZWN0cyIsImdldENsaWVudFJlY3RzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2NsaWVudFJlY3RzJGZpbmQiLCJmaXJzdFJlY3QiLCJsYXN0UmVjdCIsImlzVG9wIiwiaXNMZWZ0U2lkZSIsIm1heFJpZ2h0IiwibWluTGVmdCIsIm1lYXN1cmVSZWN0cyIsInJlc2V0UmVjdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n\n\nfunction isWindow(value) {\n    return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n    if (node == null) {\n        return window;\n    }\n    if (!isWindow(node)) {\n        const ownerDocument = node.ownerDocument;\n        return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n}\nfunction getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n    return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands) {\n        return uaData.brands.map((item)=>item.brand + \"/\" + item.version).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n    return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n    return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n    return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    const OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle$1(element);\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n    // TODO: Try and use feature detection here instead\n    const isFirefox = /firefox/i.test(getUAString());\n    const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== \"none\" || css.perspective !== \"none\" || // @ts-ignore (TS 4.1 compat)\n    css.contain === \"paint\" || [\n        \"transform\",\n        \"perspective\"\n    ].includes(css.willChange) || isFirefox && css.willChange === \"filter\" || isFirefox && (css.filter ? css.filter !== \"none\" : false);\n}\nfunction isLayoutViewport() {\n    // Not Safari\n    return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n// • Always-visible scrollbar or not\n// • Width of <html>, etc.\n// const vV = win.visualViewport;\n// return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    let scaleX = 1;\n    let scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    const win = isElement(element) ? getWindow(element) : window;\n    const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n    const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n    const width = clientRect.width / scaleX;\n    const height = clientRect.height / scaleY;\n    return {\n        width,\n        height,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x,\n        x,\n        y\n    };\n}\nfunction getDocumentElement(node) {\n    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.pageXOffset,\n        scrollTop: element.pageYOffset\n    };\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n    const rect = getBoundingClientRect(element);\n    return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent, true);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    return(// @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n    );\n}\nfunction getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n        return null;\n    }\n    return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n        currentNode = currentNode.host;\n    }\n    while(isHTMLElement(currentNode) && ![\n        \"html\",\n        \"body\"\n    ].includes(getNodeName(currentNode))){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else {\n            currentNode = currentNode.parentNode;\n        }\n    }\n    return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n    const window1 = getWindow(element);\n    let offsetParent = getTrueOffsetParent(element);\n    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\" && !isContainingBlock(offsetParent))) {\n        return window1;\n    }\n    return offsetParent || getContainingBlock(element) || window1;\n}\nfunction getDimensions(element) {\n    if (isHTMLElement(element)) {\n        return {\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    }\n    const rect = getBoundingClientRect(element);\n    return {\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { rect, offsetParent, strategy } = _ref;\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    if (offsetParent === documentElement) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent, true);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n    }\n    return {\n        ...rect,\n        x: rect.x - scroll.scrollLeft + offsets.x,\n        y: rect.y - scroll.scrollTop + offsets.y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = getWindow(element);\n    const html = getDocumentElement(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const layoutViewport = isLayoutViewport();\n        if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n    var _element$ownerDocumen;\n    const html = getDocumentElement(element);\n    const scroll = getNodeScroll(element);\n    const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if (getComputedStyle$1(body || html).direction === \"rtl\") {\n        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if ([\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(parentNode))) {\n        // @ts-ignore assume body is always available\n        return node.ownerDocument.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n    var _node$ownerDocument;\n    if (list === void 0) {\n        list = [];\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n    const win = getWindow(scrollableAncestor);\n    const target = isBody ? [\n        win\n    ].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n    const updatedList = list.concat(target);\n    return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n        let next = child;\n        do {\n            // use `===` replace node.isSameNode()\n            if (next && parent === next) {\n                return true;\n            } // @ts-ignore: need a better way to handle this...\n            next = next.parentNode || next.host;\n        }while (next);\n    }\n    return false;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    return {\n        top,\n        left,\n        x: left,\n        y: top,\n        right: left + element.clientWidth,\n        bottom: top + element.clientHeight,\n        width: element.clientWidth,\n        height: element.clientHeight\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n    if (clippingParent === \"viewport\") {\n        return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getViewportRect(element, strategy));\n    }\n    if (isElement(clippingParent)) {\n        return getInnerBoundingClientRect(clippingParent, strategy);\n    }\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n    const clippingAncestors = getOverflowAncestors(element);\n    const canEscapeClipping = [\n        \"absolute\",\n        \"fixed\"\n    ].includes(getComputedStyle$1(element).position);\n    const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    } // @ts-ignore isElement check ensures we return Array<Element>\n    return clippingAncestors.filter((clippingAncestors)=>isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n    const clippingAncestors = [\n        ...mainClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = max(rect.top, accRect.top);\n        accRect.right = min(rect.right, accRect.right);\n        accRect.bottom = min(rect.bottom, accRect.bottom);\n        accRect.left = max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nconst platform = {\n    getClippingRect,\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    isElement,\n    getDimensions,\n    getOffsetParent,\n    getDocumentElement,\n    getElementRects: (_ref)=>{\n        let { reference, floating, strategy } = _ref;\n        return {\n            reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n            floating: {\n                ...getDimensions(floating),\n                x: 0,\n                y: 0\n            }\n        };\n    },\n    getClientRects: (element)=>Array.from(element.getClientRects()),\n    isRTL: (element)=>getComputedStyle$1(element).direction === \"rtl\"\n};\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll: _ancestorScroll = true, ancestorResize: _ancestorResize = true, elementResize = true, animationFrame = false } = options;\n    const ancestorScroll = _ancestorScroll && !animationFrame;\n    const ancestorResize = _ancestorResize && !animationFrame;\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...isElement(reference) ? getOverflowAncestors(reference) : [],\n        ...getOverflowAncestors(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    let observer = null;\n    if (elementResize) {\n        let initialUpdate = true;\n        observer = new ResizeObserver(()=>{\n            if (!initialUpdate) {\n                update();\n            }\n            initialUpdate = false;\n        });\n        isElement(reference) && !animationFrame && observer.observe(reference);\n        observer.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        var _observer;\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        (_observer = observer) == null ? void 0 : _observer.disconnect();\n        observer = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */ const computePosition = (reference, floating, options)=>(0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n        platform,\n        ...options\n    });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7QUFDbUM7QUFFOUgsU0FBU2EsU0FBU0MsS0FBSztJQUNyQixPQUFPQSxTQUFTQSxNQUFNQyxRQUFRLElBQUlELE1BQU1FLFFBQVEsSUFBSUYsTUFBTUcsS0FBSyxJQUFJSCxNQUFNSSxXQUFXO0FBQ3RGO0FBQ0EsU0FBU0MsVUFBVUMsSUFBSTtJQUNyQixJQUFJQSxRQUFRLE1BQU07UUFDaEIsT0FBT0M7SUFDVDtJQUVBLElBQUksQ0FBQ1IsU0FBU08sT0FBTztRQUNuQixNQUFNRSxnQkFBZ0JGLEtBQUtFLGFBQWE7UUFDeEMsT0FBT0EsZ0JBQWdCQSxjQUFjQyxXQUFXLElBQUlGLFNBQVNBO0lBQy9EO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLFNBQVNJLG1CQUFtQkMsT0FBTztJQUNqQyxPQUFPTixVQUFVTSxTQUFTQyxnQkFBZ0IsQ0FBQ0Q7QUFDN0M7QUFFQSxTQUFTRSxZQUFZUCxJQUFJO0lBQ3ZCLE9BQU9QLFNBQVNPLFFBQVEsS0FBS0EsT0FBTyxDQUFDQSxLQUFLUSxRQUFRLElBQUksRUFBQyxFQUFHQyxXQUFXLEtBQUs7QUFDNUU7QUFFQSxTQUFTQztJQUNQLE1BQU1DLFNBQVNDLFVBQVVDLGFBQWE7SUFFdEMsSUFBSUYsVUFBVSxRQUFRQSxPQUFPRyxNQUFNLEVBQUU7UUFDbkMsT0FBT0gsT0FBT0csTUFBTSxDQUFDQyxHQUFHLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLEtBQUssR0FBRyxNQUFNRCxLQUFLRSxPQUFPLEVBQUVDLElBQUksQ0FBQztJQUN6RTtJQUVBLE9BQU9QLFVBQVVRLFNBQVM7QUFDNUI7QUFFQSxTQUFTQyxjQUFjM0IsS0FBSztJQUMxQixPQUFPQSxpQkFBaUJLLFVBQVVMLE9BQU80QixXQUFXO0FBQ3REO0FBQ0EsU0FBU0MsVUFBVTdCLEtBQUs7SUFDdEIs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SXlCLGVBQWdCRSxDQUFBQSxZQUFZL0csQ0FBQyxLQUFLNkcsWUFBWTdHLENBQUMsSUFBSStHLFlBQVkzRyxDQUFDLEtBQUt5RyxZQUFZekcsQ0FBQyxJQUFJMkcsWUFBWXBILEtBQUssS0FBS2tILFlBQVlsSCxLQUFLLElBQUlvSCxZQUFZbEgsTUFBTSxLQUFLZ0gsWUFBWWhILE1BQU0sR0FBRztZQUMvSzhGO1FBQ0Y7UUFFQWtCLGNBQWNFO1FBQ2RILFVBQVVJLHNCQUFzQkY7SUFDbEM7SUFFQW5CO0lBQ0EsT0FBTztRQUNMLElBQUlzQjtRQUVKZCxVQUFVQyxPQUFPLENBQUNDLENBQUFBO1lBQ2hCUixrQkFBa0JRLFNBQVNhLG1CQUFtQixDQUFDLFVBQVV2QjtZQUN6REksa0JBQWtCTSxTQUFTYSxtQkFBbUIsQ0FBQyxVQUFVdkI7UUFDM0Q7UUFDQ3NCLENBQUFBLFlBQVlULFFBQU8sS0FBTSxPQUFPLEtBQUssSUFBSVMsVUFBVUUsVUFBVTtRQUM5RFgsV0FBVztRQUVYLElBQUlOLGdCQUFnQjtZQUNsQmtCLHFCQUFxQlI7UUFDdkI7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUVELE1BQU1qTSxrQkFBa0IsQ0FBQ3lLLFdBQVdDLFVBQVVPLFVBQVloTCxrRUFBaUJBLENBQUN3SyxXQUFXQyxVQUFVO1FBQy9GSDtRQUNBLEdBQUdVLE9BQU87SUFDWjtBQUU2RCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcz8zZmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuZG9jdW1lbnQgJiYgdmFsdWUubG9jYXRpb24gJiYgdmFsdWUuYWxlcnQgJiYgdmFsdWUuc2V0SW50ZXJ2YWw7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICghaXNXaW5kb3cobm9kZSkpIHtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIHJldHVybiBpc1dpbmRvdyhub2RlKSA/ICcnIDogbm9kZSA/IChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogJyc7XG59XG5cbmZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcykge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChpdGVtID0+IGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbikuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBgU2hhZG93Um9vdGAgc3VwcG9ydFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1lcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICAvLyBUT0RPOiBUcnkgYW5kIHVzZSBmZWF0dXJlIGRldGVjdGlvbiBoZXJlIGluc3RlYWRcbiAgY29uc3QgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgLy8gQHRzLWlnbm9yZSAoVFMgNC4xIGNvbXBhdClcbiAgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmNsdWRlcyhjc3Mud2lsbENoYW5nZSkgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICAvLyBOb3QgU2FmYXJpXG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTsgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZm9yIHRoaXMgZmFpbHMgaW4gdmFyaW91cyB3YXlzXG4gIC8vIOKAoiBBbHdheXMtdmlzaWJsZSBzY3JvbGxiYXIgb3Igbm90XG4gIC8vIOKAoiBXaWR0aCBvZiA8aHRtbD4sIGV0Yy5cbiAgLy8gY29uc3QgdlYgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIC8vIHJldHVybiB2ViA/IE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdlYuc2NhbGUgLSB2Vi53aWR0aCkgPCAwLjUgOiB0cnVlO1xufVxuXG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgdmFyIF93aW4kdmlzdWFsVmlld3BvcnQkbywgX3dpbiR2aXN1YWxWaWV3cG9ydCwgX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiwgX3dpbiR2aXN1YWxWaWV3cG9ydDI7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgc2NhbGVYID0gMTtcbiAgbGV0IHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICBjb25zdCB3aW4gPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3c7XG4gIGNvbnN0IGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgY29uc3QgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/IChfd2luJHZpc3VhbFZpZXdwb3J0JG8gPSAoX3dpbiR2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW4kdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCkgIT0gbnVsbCA/IF93aW4kdmlzdWFsVmlld3BvcnQkbyA6IDAgOiAwKSkgLyBzY2FsZVg7XG4gIGNvbnN0IHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/IChfd2luJHZpc3VhbFZpZXdwb3J0JG8yID0gKF93aW4kdmlzdWFsVmlld3BvcnQyID0gd2luLnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbiR2aXN1YWxWaWV3cG9ydDIub2Zmc2V0VG9wKSAhPSBudWxsID8gX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiA6IDAgOiAwKSkgLyBzY2FsZVk7XG4gIGNvbnN0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgY29uc3QgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICByZXR1cm4gKChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQucGFnZVhPZmZzZXQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnBhZ2VZT2Zmc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gaXNTY2FsZWQoZWxlbWVudCkge1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICByZXR1cm4gcm91bmQocmVjdC53aWR0aCkgIT09IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgcm91bmQocmVjdC5oZWlnaHQpICE9PSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgLy8gQHRzLWlnbm9yZSAtIGNoZWNrZWQgYWJvdmUgKFRTIDQuMSBjb21wYXQpXG4gIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIGlzU2NhbGVkKG9mZnNldFBhcmVudCksIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBub2RlLmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIG5vZGUucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KG5vZGUpID8gbm9kZS5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIGdldERvY3VtZW50RWxlbWVudChub2RlKSAvLyBmYWxsYmFja1xuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFbJ2h0bWwnLCAnYm9keSddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkpIHtcbiAgICBpZiAoaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuXG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSAvLyBUaGlzIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIG5lZWQgdG8gYmUgbmVnYXRlZC5cbiAgICAvLyBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAvLyAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICAvLyB9XG5cbiAgfVxuXG4gIHJldHVybiB7IC4uLnJlY3QsXG4gICAgeDogcmVjdC54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKyBvZmZzZXRzLngsXG4gICAgeTogcmVjdC55IC0gc2Nyb2xsLnNjcm9sbFRvcCArIG9mZnNldHMueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlJDEoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG5cbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKHBhcmVudE5vZGUpKSkge1xuICAgIC8vIEB0cy1pZ25vcmUgYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IocGFyZW50Tm9kZSk7XG59XG5cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBjb25zdCB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10pIDogc2Nyb2xsYWJsZUFuY2VzdG9yO1xuICBjb25zdCB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vIEB0cy1pZ25vcmU6IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyh0YXJnZXQpKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICBjb25zdCByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcblxuICAgIGRvIHtcbiAgICAgIC8vIHVzZSBgPT09YCByZXBsYWNlIG5vZGUuaXNTYW1lTm9kZSgpXG4gICAgICBpZiAobmV4dCAmJiBwYXJlbnQgPT09IG5leHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIEB0cy1pZ25vcmU6IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfSB3aGlsZSAobmV4dCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB4OiBsZWZ0LFxuICAgIHk6IHRvcCxcbiAgICByaWdodDogbGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgYm90dG9tOiB0b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICB3aWR0aDogZWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgaWYgKGNsaXBwaW5nUGFyZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSk7XG4gIH1cblxuICBpZiAoaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSkge1xuICAgIHJldHVybiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICB9XG5cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nQW5jZXN0b3JzKGVsZW1lbnQpIHtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50KTtcbiAgY29uc3QgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uKTtcbiAgY29uc3QgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gQHRzLWlnbm9yZSBpc0VsZW1lbnQgY2hlY2sgZW5zdXJlcyB3ZSByZXR1cm4gQXJyYXk8RWxlbWVudD5cblxuXG4gIHJldHVybiBjbGlwcGluZ0FuY2VzdG9ycy5maWx0ZXIoY2xpcHBpbmdBbmNlc3RvcnMgPT4gaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3JzKSAmJiBjb250YWlucyhjbGlwcGluZ0FuY2VzdG9ycywgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nQW5jZXN0b3JzKSAhPT0gJ2JvZHknKTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgbWFpbkNsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0FuY2VzdG9ycyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLm1haW5DbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgaXNFbGVtZW50LFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0RWxlbWVudFJlY3RzOiBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmcsXG4gICAgICBzdHJhdGVneVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgICAgZmxvYXRpbmc6IHsgLi4uZ2V0RGltZW5zaW9ucyhmbG9hdGluZyksXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXRDbGllbnRSZWN0czogZWxlbWVudCA9PiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSksXG4gIGlzUlRMOiBlbGVtZW50ID0+IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnXG59O1xuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsOiBfYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplOiBfYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0cnVlLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGFuY2VzdG9yU2Nyb2xsID0gX2FuY2VzdG9yU2Nyb2xsICYmICFhbmltYXRpb25GcmFtZTtcbiAgY29uc3QgYW5jZXN0b3JSZXNpemUgPSBfYW5jZXN0b3JSZXNpemUgJiYgIWFuaW1hdGlvbkZyYW1lO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4oaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcblxuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIGxldCBpbml0aWFsVXBkYXRlID0gdHJ1ZTtcbiAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICBpZiAoIWluaXRpYWxVcGRhdGUpIHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBpc0VsZW1lbnQocmVmZXJlbmNlKSAmJiAhYW5pbWF0aW9uRnJhbWUgJiYgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2UpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICB9XG5cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuXG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJhbWVMb29wKCkge1xuICAgIGNvbnN0IG5leHRSZWZSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSk7XG5cbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG5cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuXG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfb2JzZXJ2ZXI7XG5cbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICAoX29ic2VydmVyID0gb2JzZXJ2ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIG9ic2VydmVyID0gbnVsbDtcblxuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSByZWZlcmVuY2UgZWxlbWVudCB3aGVuIGl0IGlzIGdpdmVuIGEgY2VydGFpbiBDU1MgcG9zaXRpb25pbmdcbiAqIHN0cmF0ZWd5LlxuICovXG5cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiBjb21wdXRlUG9zaXRpb24kMShyZWZlcmVuY2UsIGZsb2F0aW5nLCB7XG4gIHBsYXRmb3JtLFxuICAuLi5vcHRpb25zXG59KTtcblxuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9O1xuIl0sIm5hbWVzIjpbInJlY3RUb0NsaWVudFJlY3QiLCJjb21wdXRlUG9zaXRpb24iLCJjb21wdXRlUG9zaXRpb24kMSIsImFycm93IiwiYXV0b1BsYWNlbWVudCIsImRldGVjdE92ZXJmbG93IiwiZmxpcCIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwib2Zmc2V0Iiwic2hpZnQiLCJzaXplIiwiaXNXaW5kb3ciLCJ2YWx1ZSIsImRvY3VtZW50IiwibG9jYXRpb24iLCJhbGVydCIsInNldEludGVydmFsIiwiZ2V0V2luZG93Iiwibm9kZSIsIndpbmRvdyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUkMSIsImVsZW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwibWFwIiwiaXRlbSIsImJyYW5kIiwidmVyc2lvbiIsImpvaW4iLCJ1c2VyQWdlbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiaXNOb2RlIiwiTm9kZSIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJPd25FbGVtZW50IiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInRlc3QiLCJpc1RhYmxlRWxlbWVudCIsImluY2x1ZGVzIiwiaXNDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZmlsdGVyIiwiaXNMYXlvdXRWaWV3cG9ydCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsIl93aW4kdmlzdWFsVmlld3BvcnQkbyIsIl93aW4kdmlzdWFsVmlld3BvcnQiLCJfd2luJHZpc3VhbFZpZXdwb3J0JG8yIiwiX3dpbiR2aXN1YWxWaWV3cG9ydDIiLCJjbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0V2lkdGgiLCJ3aWR0aCIsIm9mZnNldEhlaWdodCIsImhlaWdodCIsIndpbiIsImFkZFZpc3VhbE9mZnNldHMiLCJ4IiwibGVmdCIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0TGVmdCIsInkiLCJ0b3AiLCJvZmZzZXRUb3AiLCJyaWdodCIsImJvdHRvbSIsImdldERvY3VtZW50RWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJpc1NjYWxlZCIsInJlY3QiLCJnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsInN0cmF0ZWd5IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJzY3JvbGwiLCJvZmZzZXRzIiwib2Zmc2V0UmVjdCIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9zaXRpb24iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldE9mZnNldFBhcmVudCIsImdldERpbWVuc2lvbnMiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJnZXRWaWV3cG9ydFJlY3QiLCJodG1sIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJsYXlvdXRWaWV3cG9ydCIsImdldERvY3VtZW50UmVjdCIsIl9lbGVtZW50JG93bmVyRG9jdW1lbiIsImJvZHkiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yIiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJsaXN0IiwiX25vZGUkb3duZXJEb2N1bWVudCIsInNjcm9sbGFibGVBbmNlc3RvciIsImlzQm9keSIsInRhcmdldCIsImNvbmNhdCIsInVwZGF0ZWRMaXN0IiwiY29udGFpbnMiLCJwYXJlbnQiLCJjaGlsZCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJuZXh0IiwiZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1BhcmVudCIsImdldENsaXBwaW5nQW5jZXN0b3JzIiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJyZWR1Y2UiLCJhY2NSZWN0IiwiY2xpcHBpbmdBbmNlc3RvciIsInBsYXRmb3JtIiwiZ2V0RWxlbWVudFJlY3RzIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJnZXRDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImlzUlRMIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsIm9wdGlvbnMiLCJhbmNlc3RvclNjcm9sbCIsIl9hbmNlc3RvclNjcm9sbCIsImFuY2VzdG9yUmVzaXplIiwiX2FuY2VzdG9yUmVzaXplIiwiZWxlbWVudFJlc2l6ZSIsImFuaW1hdGlvbkZyYW1lIiwiYW5jZXN0b3JzIiwiZm9yRWFjaCIsImFuY2VzdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJvYnNlcnZlciIsImluaXRpYWxVcGRhdGUiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJmcmFtZUlkIiwicHJldlJlZlJlY3QiLCJmcmFtZUxvb3AiLCJuZXh0UmVmUmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9vYnNlcnZlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ })

};
;